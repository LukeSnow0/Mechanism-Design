function Spectrum_MD()
% SPECTRUM_MD
% Mechanism design under information asymmetry (spectrum-sharing demo)
% - Players: privately optimize utilities and (via repeated play/beliefs) produce mixed-strategy equilibria.
% - Designer: does NOT observe utilities; only observes equilibrium mixed strategies for each probe.
% - Designer tunes pricing mechanism theta to minimize a revealed-preference Pareto gap via SPSA.
%
% Features:
%   * Probing constraints g_{i,t} (concave, increasing) generated by shifts (Assumption 1 style)
%   * Logit-QRE fixed-point to generate mixed strategies for each probe t
%   * Pareto gap via additive GARPF LP (linear). Minimizes F >= 0 s.t.
%       u_{i,s} - u_{i,t} - lambda_{i,t} * E[g_{i,t}(a_i) | mu_{i,s}] <= F
%   * SPSA updates on theta = [theta0;base price; theta1;congestion price]
%   * Tracks and plots both Pareto gap and Social Utility (sum_i E[f_i])
%
% Dependencies: Optimization Toolbox (linprog)
%
% Author: Luke Snow
% Date:   Oct 2025

rng(7);                       % reproducible

%% -------------------- Model dimensions & knobs ---------------------------
M   = 4;                      % number of agents
Amax= 4.0;                    % max power (W) discretization max
Na  = 25;                     % # action bins per agent
A   = linspace(0, Amax, Na)'; % discrete action levels
T   = 10;                     % # probing constraint sets

% Logit-QRE solver parameters
tau      = 6.0;               % inverse temp (larger => crisper best responses)
qre_tol  = 1e-6;              % QRE convergence tol
qre_maxit= 2000;              % QRE max iterations

% Channel/noise and private valuations (unknown to designer)
sigma2    = 0.3;              % noise floor
V         = abs(0.8 + 0.4*randn(M,1));      % private valuations v_i > 0
Alpha     = 0.3*rand(M); Alpha(1:M+1:end) = 0; % cross-interference weights α_{j->i}
                                              % (no self-interference term here)
% Probing constraint generation (designer chooses; players just face constraints)
beta      = 0.6 + 0.8*rand(M,1);      % probe direction β_i > 0
a_shifts  = 0.15 + 0.6*rand(T,1);     % probe shift a_t > 0
lambda_min= 1e-3;                     % lower bound for λ_{i,t} in LP

% Mechanism param: theta = [theta0; theta1] (base price, congestion price)
theta0 = 0.12;  theta1 = 0.06;        % initialization
theta  = [theta0; theta1];

%% -------------------- Build probing constraint masks ---------------------
% constraint per agent i, probe t, evaluated on scalar x >= 0:
%   g_{i,t}(x) = sqrt(max(x - a_t * beta_i, 0)) - 1    (concave, increasing)
% feasible set: g_{i,t}(x) <= 0  <=>  x <= a_t * beta_i + 1
g_eval = @(i,t,x) sqrt(max(x - a_shifts(t)*beta(i),0)) - 1;

% Per-(i,t) feasibility masks over action grid A
feas_mask = false(Na, M, T);
for t=1:T
    for i=1:M
        feas_mask(:,i,t) = (A <= (a_shifts(t)*beta(i) + 1 + 1e-12));  % small slack
        if ~any(feas_mask(:,i,t))
            feas_mask(1,i,t) = true;  % ensure at least one feasible action
        end
    end
end

%% -------------------- Builders: MU(theta) & Pareto gap -------------------
compute_all_mu = @(theta) local_build_MU(theta, M, A, feas_mask, V, Alpha, sigma2, ...
                                         tau, qre_tol, qre_maxit, T);

ParetoGap = @(theta, MU) garpf_gap(theta, MU, g_eval, A, feas_mask, lambda_min, M, T);

%% -------------------- Initial evaluation ---------------------------------
MU0 = compute_all_mu(theta);
assert(isequal(size(MU0), [Na*M, T]), 'MU must be (Na*M) x T; got %s.', mat2str(size(MU0)));

F0  = ParetoGap(theta, MU0);
fprintf('Initial theta = [%.4f, %.4f],   Pareto gap F = %.6f\n', theta(1), theta(2), F0);

S0  = social_utility(theta, MU0, M, A, V, Alpha, sigma2);
fprintf('Initial social utility (avg over probes) = %.6f\n', S0);

%% -------------------- SPSA optimization loop -----------------------------
Nit =2000;                  % SPSA iterations (increase for stronger convergence)
c0  = 0.15;                % perturbation scale
a0  = 0.25;                % step size scale
eta = 0.25;                % ck = c0/k^eta

gap_hist   = zeros(Nit,1);
soc_hist   = zeros(Nit,1);
theta_hist = zeros(2,Nit+1);
theta_hist(:,1) = theta;

for k=1:Nit
    ck = c0 / (k^eta);
    ak = a0 / k;

    % Rademacher perturbation
    Delta = 2*(rand(2,1) > 0.5) - 1;
    th_plus  = theta + ck.*Delta;
    th_minus = theta - ck.*Delta;

    MU_plus  = compute_all_mu(th_plus);
    F_plus   = ParetoGap(th_plus,  MU_plus);

    MU_minus = compute_all_mu(th_minus);
    F_minus  = ParetoGap(th_minus, MU_minus);

    % SPSA gradient estimate
    ghat = (F_plus - F_minus) ./ (2*ck .* Delta);

    % Update with simple projection (prices bounded)
    theta = theta - ak * ghat;
    theta(1) = max(0.0, min(theta(1), 2.0));  % theta0 in [0, 2]
    theta(2) = max(0.0, min(theta(2), 2.0));  % theta1 in [0, 2]

    % Evaluate at new theta
    MU_cur  = compute_all_mu(theta);
    F_cur   = ParetoGap(theta, MU_cur);
    S_cur   = social_utility(theta, MU_cur, M, A, V, Alpha, sigma2);

    gap_hist(k)  = F_cur;
    soc_hist(k)  = S_cur;
    theta_hist(:,k+1) = theta;

    fprintf('Iter %3d: F=%.6f | SU=%.6f | theta=[%.4f, %.4f]\n', ...
            k, F_cur, S_cur, theta(1), theta(2));

    if F_cur <= 1e-4
        gap_hist = gap_hist(1:k);
        soc_hist = soc_hist(1:k);
        theta_hist = theta_hist(:,1:k+1);
        break;
    end
end

%% -------------------- Plots & final report -------------------------------
figure('Color','w');
yyaxis left
plot(gap_hist,'LineWidth',1.8); grid on
ylabel('Pareto gap');
yyaxis right
plot(soc_hist,'LineWidth',1.8);
ylabel('Social utility (avg over probes)');
xlabel('SPSA iteration');
title('Pareto Gap and Social Utility vs Iteration');

fprintf('\nFinal theta = [%.5f, %.5f]\n', theta(1), theta(2));
fprintf('Final Pareto gap F = %.6f\n', gap_hist(end));
fprintf('Final social utility (avg over probes) = %.6f\n', soc_hist(end));

end % ======= end main =======


% ========================= Subfunctions ===================================

function MU = local_build_MU(theta, M, A, feas_mask, V, Alpha, sigma2, tau, qre_tol, qre_maxit, T)
% Build MU(theta) as (Na*M) x T, stacking agents for each probe column-wise
Na = numel(A);
MU = zeros(Na*M, T);
for t = 1:T
    MU(:, t) = vecQRE_for_probe(t, theta, M, A, feas_mask(:,:,t), ...
                                V, Alpha, sigma2, tau, qre_tol, qre_maxit);
end
end

function MU_col = vecQRE_for_probe(t, theta, M, A, feas_mask_t, V, Alpha, sigma2, tau, tol, maxit)
% Compute a logit QRE for a single probe t
Na = numel(A);
mu = zeros(Na, M);

% Initialize uniform on feasible actions
for i=1:M
    mask = feas_mask_t(:,i);
    z = zeros(Na,1);
    z(mask) = 1/sum(mask);
    mu(:,i) = z;
end

theta0 = theta(1); theta1 = theta(2);

for it=1:maxit
    mu_prev = mu;

    % Expected actions (mean-field)
    Eaj  = A' * mu;   % 1 x M
    sumE = sum(Eaj);

    % Best responses
    for i=1:M
        I_i = sigma2 + sum(Alpha(:,i)'.*Eaj) - Alpha(i,i)*Eaj(i);
        I_i = max(I_i, 1e-6);

        val_term  = V(i) * log(1 + A./I_i);
        cost_term = theta0*A + theta1*(sumE)*A;
        EU        = val_term - cost_term;

        mask   = feas_mask_t(:,i);
        logits = -inf(Na,1);
        logits(mask) = tau * EU(mask);

        m = max(logits);
        probs = exp(logits - m);
        probs(~isfinite(probs)) = 0;
        s = sum(probs);
        if s == 0
            p = zeros(Na,1); p(mask) = 1/sum(mask);
        else
            p = probs/s;
        end
        mu(:,i) = p;
    end

    if max(abs(mu(:)-mu_prev(:))) < tol
        break;
    end
end

MU_col = reshape(mu, Na*M, 1);  % stack [mu_1; mu_2; ...; mu_M]
end

function F = garpf_gap(theta, MU, g_eval, A, feas_mask, lambda_min, M, T)
% Compute additive GARPF gap F via LP:
% Variables:
%   - u_{i,t} (free), lambda_{i,t} >= lambda_min, and F >= 0
% Constraints for all (i,t,s):
%   u_{i,s} - u_{i,t} - lambda_{i,t} * g_{i,t}(mu_s) <= F
%
% g_{i,t}(mu_s) = E_{a_i ~ mu_{i,s}} [ g_{i,t}(a_i) ].

Na = numel(A);

% Precompute g_{i,t}(mu_s)
g_mat = zeros(M, T, T); % (i, t, s)
for t1=1:T
    for i=1:M
        gi_on_actions = arrayfun(@(a) g_eval(i, t1, a), A);  % Na x 1
        for s=1:T
            mu_is = MU(((i-1)*Na+1):(i*Na), s);
            % Zero mass on infeasible (if any)
            mask = feas_mask(:,i,s);
            mu_is(~mask) = 0;
            if sum(mu_is)>0
                mu_is = mu_is / sum(mu_is);
            else
                mu_is = zeros(Na,1); mu_is(1) = 1;
            end
            g_mat(i, t1, s) = gi_on_actions' * mu_is;
        end
    end
end

% Decision vector x = [u(:); lambda(:); F]
n_u = M*T;
n_l = M*T;
n_x = n_u + n_l + 1;

% Objective: minimize F
f = zeros(n_x,1); f(end) = 1;

% Inequalities: for each (i,t,s):
%   u_{i,s} - u_{i,t} - lambda_{i,t} * g_{i,t}(mu_s) <= F
% -> Aineq * x <= 0  (move F to LHS as -F)
n_cons = M*T*T;
Aineq = zeros(n_cons, n_x);
bineq = zeros(n_cons, 1);

u_idx = @(i,t) sub2ind([M,T], i,t);         % 1..M*T
l_idx = @(i,t) n_u + sub2ind([M,T], i,t);   % shift after u's

row = 0;
for i=1:M
    for t=1:T
        for s=1:T
            row = row + 1;
            Aineq(row, u_idx(i,s)) =  1;
            Aineq(row, u_idx(i,t)) =  Aineq(row, u_idx(i,t)) - 1;
            Aineq(row, l_idx(i,t)) = -g_mat(i,t,s);
            Aineq(row, n_x)        = -1;  % -F
            bineq(row) = 0;
        end
    end
end

% Bounds: u free, lambda in [lambda_min, +inf), F in [0, +inf)
lb = [-inf(n_u,1);  lambda_min*ones(n_l,1);  0];
ub = [ inf(n_u,1);  inf(n_l,1);             inf];

opts = optimoptions('linprog','Display','none','Algorithm','dual-simplex');
[~, fval, exitflag] = linprog(f, Aineq, bineq, [], [], lb, ub, opts);

if exitflag <= 0
    F = 1e3;  % penalty if numerical issue
else
    F = fval;
end
end

function SU = social_utility(theta, MU, M, A, V, Alpha, sigma2)
% SOCIAL_UTILITY  Expected sum of utilities across agents, averaged over probes.
% Uses the same mean-field interference approximation as in vecQRE_for_probe.
Na = numel(A);
T  = size(MU, 2);
theta0 = theta(1); theta1 = theta(2);

SU_t = zeros(T,1);
for s = 1:T
    mu_blocks = reshape(MU(:,s), Na, M);   % Na x M
    Eaj  = A' * mu_blocks;                 % 1 x M
    sumE = sum(Eaj);

    total = 0;
    for i = 1:M
        I_i = sigma2 + sum(Alpha(:,i)'.*Eaj) - Alpha(i,i)*Eaj(i);
        I_i = max(I_i, 1e-6);

        val_term  = V(i) * log(1 + A./I_i);
        cost_term = theta0*A + theta1*(sumE)*A;
        EU_i_per_action = val_term - cost_term;

        mu_i = mu_blocks(:,i);
        total = total + (mu_i' * EU_i_per_action);
    end
    SU_t(s) = total;
end

SU = mean(SU_t);
end
